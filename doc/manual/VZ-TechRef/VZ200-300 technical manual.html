<html>
<head>
  <title>VZ200 Technical Manual</title>
</head>
<body background="bg-grid.png">
<a name="title"></a>

<p>&nbsp;</p>

<p>&nbsp;</p>

<div style="text-align:center"><img src="techlogo.png" alt="VZ200/VZ300 Technical Manual" width="512" height="384"></div>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<div style="text-align:center"><img src="dselogo.png" alt="Dick Smith Electronics Pty. Ltd." width="384" height="128"></div>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr />

<h2><a name="foreword">FOREWORD</a> </h2>

<p>This manual is intended to provide owners of the VZ200/300 series of personal colour computers with additional information to assist in programming, operation and expansion. All reasonable care has been taken to ensure that the information contained herein is accurate and correct; however no responsibility can be accepted, nor liability assumed for either its accuracy or suitability for any particular purpose. Dick Smith Management Pty Ltd reserves the right to make circuit, software and/or mechanical changes to the products described herein, without notice.</p>

<p>Although much of this information contained herein will be of interest to all VZ200/300 owners, it is assumed that the reader is reasonably familiar with the technicalities of digital computer electronics. It is strongly recommended that owners without suitable experience in the field of computer service techniques not attempt to repair or modify their computer's equipment.</p>

<hr />

<h2>NOTE ON E-TEXT VERSION</h2>

<p>This E-Text is supplied to the VZ-200 enthusiast community at no charge and on the assumption that <cite>Dick Smith Electronics</cite> has no objection to obsolete databooks being re-distributed in this way provided they are properly attributed.</p>

<p>The copyright remains with <cite>Dick Smith Electronics</cite>.</p>

<hr />

<h2><a name="contents">CONTENTS</a></h2>

<ul>
  <li><a href="#title">TITLE PAGE</a></li>
  <li><a href="#foreword">FOREWORD</a></li>
  <li><a href="#contents">CONTENTS</a></li>
  <li>HARDWARE
  <ul>
    <li><a href="#computers">THE BASIC COMPUTERS</a></li>
    <li><a href="#specifications">SPECIFICATIONS</a></li>
    <li><a href="#screenformat">SCREEN FORMAT</a>
    <ul>
      <li>MODE 0</li>
      <li>MODE 1</li>
      <li>VIDEO OUTPUT</li>
      <li>RF OUTPUT</li>
    </ul></li>
    </li>
    <li><a href="#keyboard">KEYBOARD</a></li>
    <li><a href="#power">POWER SUPPLIES</a></li>
    <li><a href="#circuitry">CPU AND ASSOCIATED CIRCUITRY</a>
    <ul>
      <li>VZ200</li>
      <li>VZ300</li>
    </ul></li>
    <li><a href="#ramrom">RAM AND ROM</a>
    <ul>
      <li>VZ200</li>
      <li>VZ300</li>
    </ul></li>
    <li><a href="#thekeyboard">THE KEYBOARD</a>
    <ul>
      <li>VZ200</li>
      <li>VZ300</li>
    </ul></li>
    <li><a href="#videoif">THE VIDEO INTERFACE</a>
    <ul>
      <li>5OHz SYNC GENERATION</li>
      <li>VIDEO DISPLAY MODES
      <ul>
        <li>MODE 0</li>
        <li>MODE 1</li>
      </ul></li>
    </ul></li>
    <li><a href="#iomap">I/O MAPPING</a></li>
    <li>WEIGHTING BIT FUNCTION
    <ul>
      <li>Speaker</li>
      <li>Cassette output</li>
      <li>VDC display mode</li>
      <li>VDC background colour control</li>
    </ul></li>
    <li><a href="#joysticks">JOYSTICKS</a></li>
    <li><a href="#diskcon">VZ200/300 DISK CONTROLLER</a></li>
    <li><a href="#diskdrive">VZ200/300 DISK DRIVE</a>
    <ul>
      <li>General Operation</li>
      <li>READ/WRITE and CONTROL ELECTRONICS</li>
      <li>DRIVE MECHANISM</li>
      <li>R/W HEAD POSITIONING MECHANISM</li>
      <li>R/W HEAD</li>
      <li>TRACK 0 STOPPING MECHANISM</li>
      <li>DRIVE SELECTION</li>
      <li>FILE PROTECTION MECHANISM</li>
      <li>FUNCTION of TEST POINTS</li>
      <li>FUNCTION of VARIABLE RESISTORS</li>
      <li>TROUBLESHOOTING GUIDE</li>
      <li>LISTING OF DISK CONTROL PROGRAM</li>
   </ul></li>
   <li>Schematics (loads new document)
   <ul>
     <li><a href="VZ200schem.png">VZ200 Keyboard, CPU, ROM, VDP and Casette Interface</a></li>
     <li><a href="VZ200ram.png">VZ200 6k Internal Program RAM</a></li>
     <li><a href="VZ200vidsync.png">VZ200 Video Sync</a></li>
     <li><a href="VZ200vidchrom.png">VZ200 Video and Chroma</a></li>
     <li><a href="VZ200iocon.png">VZ200 I/O and Memory Expansion Connections</a></li>
     <li><a href="VZ200memexp.png">VZ200 16k Memory Expansion Module</a></li>
     <li><a href="VZ300schem.png">VZ300 Keyboard, CPU, ROM, VDP and Casette Interface</a></li>
     <li><a href="VZ300sup.png">VZ300 Chroma, Video, RF, Power Supply and Casette Interface</a></li>
     <li><a href="VZ300iocon.png">VZ300 I/O Connections</a></li>
     <li><a href="VZ300board.png">VZ300 PCB Component Layout</a></li>
     <li><a href="VZprinter.png">VZ200 Printer Interface</a></li>
     <li><a href="VZprinterMk2.png">VZ200/300 Printer Interface (late version)</a></li>
     <li><a href="VZjoysticks.png">VZ200/300 Joystick Interface</a></li>
     <li><a href="VZdiskctrl.png">VZ200/300 Disk Controller</a></li>
     <li><a href="VZdiskdrv.png">VZ200/300 Disk Drive</a></li>
     <li><a href="VZdiskmot.png">VZ200/300 Disk Drive Motor Control</a></li>
    </ul></li>
    <li><a href="VZ300troubleshooting.png">VZ300 TROUBLE SHOOTNG GUIDE</a> (loads new document)</li>
  </ul></li>
  <li>SOFTWARE
  <ul>
    <li><a href="#screencodes">VZ200/300 SCREEN CONTROL CODES</a></li>
    <li><a href="#sysptrs">VZ200/300 SYSTEM POINTERS AND VARIABLE STORAGE LOCATIONS</a></li>
    <li><a href="#machinecode">RESERVING SPACE FOR A MACHINE CODE PROGRAM</a></li>
    <li><a href="#machineroutines">CALLING A MACHINE CODE ROUTINE FROM BASIC</a></li>
    <li><a href="#romsubs">USEFUL ROM SUBROUTINES FOR ASSEMBLY PROGRAMMING</a>
    <ul>
      <li>KEYBOARD SCANNING ROUTINE</li>
      <li>CHARACTER OUTPUT</li>
      <li>MESSAGE OUTPUT SUBROUTINE</li>
      <li>COMPARE SYMBOL (EXAMINE STRING) - RST 08H</li>
      <li>LOAD &amp; CHECK NEXT CHARACTER IN STRING -- RST 10H</li>
      <li>COMPARE DE &amp; HL REGISTER PAIRS - RST 18H</li>
      <li>SOUND DRIVER</li>
      <li>"BEEP" ROUTINE</li>
      <li>CLEAR SCREEN</li>
      <li>PRINTER DRIVER</li>
      <li>CHECK PRINTER STATUS</li>
      <li>SEND CR-LF TO PRINTER</li>
    </ul></li>
    <li><a href="#vzdos">VZ200/300 DISK OPERATING SYSTEM (DOS) ANALYSIS</a>
    <ul>
      <li>DISKETTE FORMATTING</li>
      <li>RECORDING TECHNIQUE</li>
      <li>THE STRUCTURE OF THE DOS</li>
      <li>DISK STRUCTURE</li>
      <li>DOS ENTRY POINTS</li>
      <li>DOS SUBROUTINES</li>
    </ul></li>
  </ul></li>
</ul>

<hr />

<h2><a name="computers">THE BASIC COMPUTERS</a></h2>

<p>The VZ200/300 computers employ a Z80A microprocessor running at approximately 3.6MHz. A Microsoft Basic interpreter and I/O routines are contained in 16K of mask-programmed ROM. Included in the computers are user RAM, a PAL colour video display circuit, a VHF RF modulator, a "QWERTY" keyboard, a cassette interface and a simple sound effects circuit. Also included is provision for memory and I/O expansion via two rear edge connectors. Devices which can be plugged into these connectors include a 16K RAM expansion cartridge, printer interface, floppy diskette interface and game joysticks.</p>
</a>
<hr />

<h2><a name="specifications">SPECIFICATIONS</a></h2>

<table width="384">
  <tr><td><h3>Hardware</h3></td><td><b>VZ200</b></td><td><b>VZ300</b></td></tr>
  <tr><td>CPU</td><td>Z80A</td><td>Z80A</td></tr>
  <tr><td>Clock Speed</td><td>3.58MHz</td><td>3.54MHz</td></tr>
  <tr><td>Internal ROM</td><td>16k</td><td>16k</td></tr>
  <tr><td>Internal RAM</td><td>6k</td><td>16k</td></tr>
  <tr><td>Display RAM</td><td>2k</td><td>2k</td></tr>
</table>

<h3><a name="screenformat">Screen Format</a></h3>

<h4>MODE 0</h4>

<p>16 lines of 32 characters. 128,upper-case text characters in normal or inverse format plus 128 2 pixel X 2 pixel chunky graphics characters in 8 colours.</p>

<h4>MODE 1</h4>

<p>64 rows of 128 individually addressable pixels in 4 colours.</p>

<h3>Video Output</h3>

<p>1V p-p into 75 ohms composite video, negative sync. PAL colour encoded.</p>

<h3>RF Output</h3>

<p>1mV into 75 ohms VHF Ch. 1 (57.25Mhz) PAL colour encoded.</p>

<h3><a name="keyboard">Keyboard</a></h3>

<p>45 key "QWERTY" style.</p>

<h3><a name="power">Power Supply</a></h3>

<p>The computer is powered from a 10-12V 800MA dc source. Normally this will be an approved "plug-pack" although battery powered operation is also possible. In both models the raw dc input is regulated by a 3 terminal regulator IC to 5V dc which powers most of the internal circuitry.</p>

<p>In the <b>VZ200</b>, the colour encoder circuitry requires a +12V rail which is generated from the +5V rail by a regulating inverter circuit.</p>

<p>In the <b>VZ300</b>, additional supply rails of +12V and -5V are required to power the dynamic RAMS. These voltages are generated from the raw dc supply by an inverter circuit comprising Q2, Q3 and associated components.</p>

<h3><a name="circuitry">CPU and Associated Circutry</a></h3>

<h4>VZ200</h4>

<ul>
  <li>The CPU is clocked by a 3.5795MHz crystal oscillator, comprising 3 inverters (Ul3).</li>
  <li>The -RESET pulse is generated by a simple RC circuit and buffered by 2 inverters (Ul3).</li>
  <li>The -INT input is activated during screen retrace periods by the video circuitry. The interrupt is serviced by a ROM routine which performs some housekeeping and provides a user book. The condition of the -INT input can also be sampled as bit 7 during reads of the keyboard addresses (680OH-6FFFH).</li>
  <li>The signals, -NMI, -WAIT, -RFSH, -Ml, -HALT, and -IORQ are not used within the machine but are available at the rear expansion connectors, as are all of the Z80 address, data, control and status signals with the exception of -BUSACK and -BUSREQ.</li>
</ul>

<h4>VZ300</h4>

<p>The VZ300 differs in the following ways:</p>

<ul>
  <li>The CPU is clocked at 3.5469MHz. This is obtained by division of the master oscillator by 5 within UIO. The 17.734MHz master oscillator, comprising 3 inverters (u9), is also divided by 4 to provide the 4.43362MHz PAL subcarrier.</li>
  <li>The RC derived -RESET pulse is buffered by 2 inverters of U9.</li>
</ul>

<hr />

<h2><a name="ramrom">RAM AND ROM</a></h2>

<h3>VZ200</h3>

<p>6K of program RAM is provided, implemented as three 2K x 8 static RAMS (U2', U3', U4') mounted on a small daughter board. U2' occupies addresses 780OH-7FFFH and is enabled by the address decoder circuit on the main pcb (U2, U3). U3' and U4' occupy addresses 800OH-87FFH (U3') and 880OH-8FFFH (U4') and are enabled by Ul'.</p>

<p>Another 2K x 8 RAM (U7) is used for the video display buffer. The video RAM occupies addresses 7600H,-77FFH and is enabled for CPU access by U2 and U3. For CPU reads, the video RAM data is buffered by U14. The video RAM address lines are decoupled from the CPU address lines by series resistors to avoid conflicts between the CPU and the Video Display Processor (Ul5) at times other than CPU access to the video RAM.</p>

<p>The BASIC interpreter and I/O routines are contained in 16K of ROM addressed in the range OOOOH-3FFFH. In early VZ200s this is implemented as two 8K x 8 devices (U9, U10). U9 occupies addresses, 0000-lFFFH and U10 occupies 200OH-3FFFH. Later machines use a single 16K x 8 ROM. To address the larger ROM over the 0000-3FFFH range, A13 is taken to the ROM (pin 26) and the ROM chip select (pin 20) is generated by 'ORing' the two ROM select signals from U3 with a pair of diodes.</p>

<h3>VZ300</h3>

<p>16K of program RAM is provided implemented as eight 16K x 1 dynamic RAMS (Ul-B). The RAM occupies the 16K address block 780OH-B7FFH. A custom gate array (UlO) contains all of the necessary circuitry to enable the RAM, multiplex the CPU address and provide the correct -CAS and refresh timing.</p>

<p>A 2K x 8 RAM (Ul6) is used for the video display buffer. The video RAM occupies addresses 700OH-77FFH and is enabled for CPU access by the address decoder within U14. For CPU reads, the video RAM data is buffered by U14. The video RAM address lines are decoupled from the CPU address lines by series resistors to avoid conflicts between the CPU and the Video Display Processor (Ul5-) at times other than CPU access to the video RAM.</p>

<p>The BASIC interpreter and I/O routines are contained in a single 16K x 8 ROM enabled for the 0000-3FFFH address range by address decoding circuitry within U13.</p>

<h2>MEMORY MAP</h2>

<p><img src="memmap.png" width="768" height="1024"></p>

<hr />

<h2><a name="thekeyboard">THE KEYBOARD</a></h2>

<p>The 45 keys are arranged in a 6 x 8 matrix. Each of the 8 rows effectively occupies a specific memory address (actually, a series of addresses due to the simplified decoding) in the range 6800-6FFFH. The individual keys are mapped onto the least significant 6 bits of that location, according to the column they occupy.</p>

<p>The 8 least significant bits of the address bus pull down the rows of the matrix through diodes. The keyboard is scanned by software sequentially taking each of these 8 lines to a logic low level. If the upper 8 address lines represent 68H (or, in fact, 69H-6FH) then the condition of the 6 key columns o the particular row will be enabled onto the data bus through U12.</p>

<p>For example, if the '2' key were pressed, it would cause bit 1 at address 68V7H to drop to 0. The data retrieved by reading that address, neglecting the 2 most significant bits which are not driven by the keyboard, would be 3DH (binary 111101).</p>

<p>The keyboard matrix and its (lowest) row addresses are shown below. Note that each key causes a logic 0 to appear at the bit position shown, when its row address is read.</p>

<table style="text-align:center" border="1" bgcolor="white">
  <tr style="text-align:center">
    <td rowspan="2"><b>Row Address</b></td>
    <td colspan="6"><b>Bit Position</b></td>
  </tr>
  
  <tr style="text-align:center">
    <td width="64"><b>5</b></td>
    <td width="64"><b>4</b></td>
    <td width="64"><b>3</b></td>
    <td width="64"><b>2</b></td>
    <td width="64"><b>1</b></td>
    <td width="64"><b>0</b></td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68FE</td>
    <td>R</td>
    <td>Q</td>
    <td>E</td>
    <td></td>
    <td>W</td>
    <td>T</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68FD</td>
    <td>F</td>
    <td>A</td>
    <td>D</td>
    <td>[CTRL]</td>
    <td>S</td>
    <td>G</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68FB</td>
    <td>V</td>
    <td>Z</td>
    <td>C</td>
    <td>[SHIFT]</td>
    <td>X</td>
    <td>B</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68F7</td>
    <td>4</td>
    <td>1</td>
    <td>3</td>
    <td></td>
    <td>2</td>
    <td>5</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68EF</td>
    <td>M</td>
    <td>[SPACE]</td>
    <td>,</td>
    <td></td>
    <td>.</td>
    <td>N</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68DF</td>
    <td>7</td>
    <td>0</td>
    <td>8</td>
    <td>-</td>
    <td>9</td>
    <td>6</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x68BF</td>
    <td>U</td>
    <td>P</td>
    <td>I</td>
    <td>[RETURN]</td>
    <td>O</td>
    <td>Y</td>
  </tr>
  
  <tr style="text-align:center">
    <td>0x687F</td>
    <td>J</td>
    <td>;</td>
    <td>K</td>
    <td>:</td>
    <td>L</td>
    <td>H</td>
  </tr>
</table>

<h3>VZ300</h3>

<p>The VZ300 keyboard is logically the same as the VZ200, although it is read through a custom I/O IC (14). Physically the VZ300 keyboard differs in that it uses the more common, moulded keys and has a full space bar.</p>

<hr />

<h2><a name="videoif">THE VIDEO INTERFACE</a></h2>

<p>The heart of the video interface is a 6847 video Display processor. This IC contains the upper-case ASCII and chunky graphics character generator, and, logic to produce the dot addressable graphics, the video timing signals, the video RAM control and address signals, a video luminance (Y) output and 2 matrixed colour outputs (R-Y and B-Y)</p>

<h3>5OHz SYNC GENERATION</h3>

<p>The 6847 is intended to produce 6OHz vertical synchronization signals and 262 lines per field. In order to produce 5OHz 312 line video signals, 50 extra lines must be added to each field. This is achieved by 3 counters, U18, U20, U21 and associated logic.</p>

<p>When the VDP outputs -FS, the reset inputs to U20 are released, allowing it to count video lines from the VDP. U20 counts the first 25 lines of the bottom border and then inhibits the 3.58MHz video clock via U16 and U19. Instead of clocking the VDP, the clock is fed to U18 which is configured as a divide-by-228 counter. U18 generates horizontal sync pulses (between clock edges 208 and 228) during the period that the VDP is disabled. U21 counts these "dummy" video lines. When 25 additional lines have been completed, the clock is switched back to the VDP. The VDP generates a further 7 lines before resetting -FS. This again inhibits the VDP and allows U18, U21 etc. to insert a further 25 "dummy" lines. The VDP is then allowed to operate as normal for the next 230 lines after which the cycle repeats itself. In summary, starting from the falling edge of -FS, the 312 line cycle is as follows:</p>

<ul>
  <li>25 lines of bottom border (from VDP)</li>
  <li>25 lines of bottom border (from U18, etc.)</li>
  <li>1 line of bottom border (from VDP)</li>
  <li>6 lines of vertical retrace (from VDP)</li>
  <li>13 lines of blanking (from U18, etc.)</li>
  <li>12 lines of top border (from U18, etc.)</li>
  <li>38 lines of top border (from VDP)</li>
  <li>192 lines of active display (from VDP)</li>
</ul>

<h3>VIDEO DISPLAY MODES</h3>

<p>The video interface operates in one of two modes, text/low-res graphics (MODE 0) or hi-res (MODE 1). The display mode is determined from the -A/G input on the VDP (pin 35). This input is controlled by bit 3 of the Cassette/speaker/VDP control latch. If bit 3 is set then MODE 1 is enabled.</p>

<h3>MODE 0</h3>

<p>In MODE 0 the screen is organised as 16 rows of 32 characters. Each screen location is represented by a unique memory location in the first 512 bytes of the video RAM (i.e. 7000H - 71FFH, or 28672 - 29183 decimal).</p>

<p>The background colour in this mode is determined by the condition of pin 39 of the VDP (CSS). If CSS is set, then the background colour is orange; if it is reset then the background is green. CSS is controlled by bit 4 of the Cassette/speaker/VDP control latch.</p>

<p>A total of 256 different characters can be displayed consisting of 64 upper-case characters, the same 64 characters in inverse format and 128 lo-res graphic characters. Bit 7 of the video character data determines whether the character is text (bit 7=0) or graphic (bit 7=1).</p>

<p>If bit 7 is reset, indicating a text character, then bit 6 determines whether it is displayed in normal (bit 6=0, light on dark) or inverse (bit 6=1, dark on light) format. The remaining 6 bits are the character code.</p>

<p>If bit 7 is set, indicating a graphic character, then bits 4, 5 and 6 indicate the colour of the character and bits 0, 1, 2 and 3 determine its shape. Each of the 4 least significant bits corresponds to a pixel in a 2 x 2 matrix which occupies the same screen area as a text character.</p>

<p>The 3 bit colour code is:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td><b>B6</b></td>
    <td><b>B5</b></td>
    <td><b>B4</b></td>
    <td><b>HEX</b></td>
    <td><b>COLOUR</b></td>
  </tr>
  <tr style="text-align:center">
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>00</td>
    <td>Green</td>
  </tr>
  <tr style="text-align:center">
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>10</td>
    <td>Yellow</td>
  </tr>
  <tr style="text-align:center">
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>20</td>
    <td>Blue</td>
  </tr>
  <tr style="text-align:center">
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>30</td>
    <td>Red</td>
  </tr>
  <tr style="text-align:center">
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>40</td>
    <td>Buff</td>
  </tr>
  <tr style="text-align:center">
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>50</td>
    <td>Cyan</td>
  </tr>
  <tr style="text-align:center">
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>60</td>
    <td>Magenta</td>
  </tr>
  <tr style="text-align:center">
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>70</td>
    <td>Orange</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>Bits 0-3 of the graphics character code are mapped onto pixels as shown below:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td>B3</td>
    <td>B2</td>
  </tr>
  <tr style="text-align:center">
    <td>B1</td>
    <td>B0</td>
  </tr>
</table>

<h3>MODE 1</h3>

<p>In this mode the screen is organized as 64 rows of 128 pixels, giving a total of 8192 pixels. Each pixel can be displayed in one of four corners, one of which is the background colour. This means that for each of the two possible background colours, each pixel can be either 'turned off' (ie the same colour as the background), or displayed in one of three colours.</p>

<p>The video RAM coding scheme used for this display mode uses each byte to encode four adjacent pixels. This means that each pixel is encoded in two bits. To illustrate this, here is the coding for the first four pixels on the screen, in the top left hand corner:</p>

<p>Address 0x7000:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td colspan="2">Pixel 0</td>
    <td colspan="2">Pixel 1</td>
    <td colspan="2">Pixel 2</td>
    <td colspan="2">Pixel 3</td>
  </tr>
  <tr style="text-align:center">
    <td>B7</td>
    <td>B6</td>
    <td>B5</td>
    <td>B4</td>
    <td>B3</td>
    <td>B2</td>
    <td>B1</td>
    <td>B0</td>
  </tr>
</table>

<p>The next four pixels along the line are stored in location 0x7001, and so on. The 2-bit colour coding used for each pixel is shown below:</p>

<p>Background colour 0 (green):</p>

<table border="1" bgcolor="white">
  <tr>
    <td>00</td>
    <td>Green (background colour)</td>
  </tr>
  <tr>
    <td>01</td>
    <td>Yellow</td>
  </tr>
  <tr>
    <td>10</td>
    <td>Blue</td>
  </tr>
  <tr>
    <td>11</td>
    <td>Red</td>
  </tr>
</table>

<p>Background colour 1 (buff):</p>

<table border="1" bgcolor="white">
  <tr>
    <td>00</td>
    <td>Buff (background colour)</td>
  </tr>
  <tr>
    <td>01</td>
    <td>Cyan</td>
  </tr>
  <tr>
    <td>10</td>
    <td>Orange</td>
  </tr>
  <tr>
    <td>11</td>
    <td>Magenta</td>
  </tr>
</table>

<p>Note that from BASIC, any pixel may be individually turned on or off using the SET(x,y) and RESET(x,y) commands, and given various colours using the COLOR(m,n) command.</p>

<hr />

<h2><a name="iomap">I/O MAPPING</a></h2>

<p>The Z80A microprocessor in the VZ200/300 can address 256 ports in I/O space (ie ports 0 - FF hex). The following I/O address ranges have been allocated for expansion peripherals:</p>

<table border="1" bgcolor="white">
  <tr>
    <td><b>I/O Address (HEX)</b></td>
    <td style="text-align:center"><b>Device</b></td>
  </tr>
  <tr>
    <td style="text-align:center">00-0F</td>
    <td>Printer</td>
  </tr>
  <tr>
    <td style="text-align:center">10-1F</td>
    <td>Floppy Disk Controller</td>
  </tr>
  <tr>
    <td style="text-align:center">20=2F</td>
    <td>Joystick Interface</td>
  </tr>
  <tr>
    <td style="text-align:center">30-3F</td>
    <td>Communications MODEM</td>
  </tr>
  <tr>
    <td style="text-align:center">70-7F</td>
    <td>Memory Bank Switch</td>
  </tr>
</table>

<hr />

<h2>VZ200/300 CASSETTE/SPEAKER/VDC OUTPUT LATCH</h2>

<p>An internal latch is used to generate the cassette output, the drive for the internal piezo speaker, and two control signals for the video display controller chip (6847). The latch is write-only and memory-mapped occupying all addresses from 6800H - 6FFFH (26624 - 28671 decimal) inclusive. In the VZ200 this latch is Ul (74LS174), whereas in the VZ300 this latch is part of U14 (the GA004 LSI). A bit-map of the latch is shown below:</p>

<table border="1" bgcolor="white">
  <tr>
    <td><b>Bit</b></td>
    <td><b>Function</b></td>
  </tr>
  <tr>
    <td style="text-align:center">5</td>
    <td>Speaker B</td>
  </tr>
  <tr>
  <td style="text-align:center">4</td>
    <td>VDC Background</td>
    <td>0 = green</td>
    <td>1 = orange (text mode) / buff (graphics mode)</td>
  </tr>
  <tr>
  <td style="text-align:center">3</td>
    <td>VDC Display Mode</td>
    <td>0 = mode0 (text mode)</td>
    <td>1 = mode1 (graphics mode)</td>
  </tr>
  <tr>
    <td style="text-align:center">2</td>
    <td>Casette out (MSB)</td>
  </tr>
  <tr>
    <td style="text-align:center">1</td>
    <td>Casette out (LSB)</td>
  </tr>
  <tr>
    <td style="text-align:center">0</td>
    <td>Speaker A</td>
  </tr>
</table>

<h3>Speaker</h3>

<p>The speaker is driven in push-pull fashion by bits 0 and 5. To make the speaker sound a note, the software should toggle bits 0 and 5 alternately at the required rate. ie when bit 0 is a logic Oil, bit 5 should be logic 'O' and vice-versa. Note that when this is done the software should not alter the other bits of the latch.</p>

<h3>Cassette output</h3>

<p>Bits 1 and 2 are used to generate the cassette recording signal, which is approximately 200 millivolts peak-to-peak.</p>

<h3>VDC display mode</h3>

<p>The VDC display mode is controlled by bit 3. If bit 3 is a logic 10', the VDC will operate in its text/low-resolution mode. If bit 3 is made logic '1', the VDC operates in its hi-res graphics-only mode.</p>

<h3>VDC background colour control</h3>

<p>Bit 4 is used to control the VDC background colour. In text/low- res mode (mode 0), a '0' on bit 4 gives a <u>green</u> background colour while a '1' on bit 4 gives an <u>orange</u> background. In hi-res mode (mode 1) a '0' on bit 4 gives a <u>green</u> background, while a '1' gives a <u>buff</u> background.</p>

<hr />

<h2><a name="joysticks">JOYSTICKS</a></h2>

<p>The two Joystick units are connected to a plug-in module that contains I/O address decoding and switch matrix encoding. IC U2 (74LS138) enables I/O reads between 20 - 2F Hex. Address lines AO - A3 are used separately to generate active LOW signals on the joystick or switch to be read. Switch state is then read at the resultant address from Data bits DO - D4. When a switch is ON it provides an active-low Data bit. As below:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td><b>I/O Address</b></td>
    <td><b>Joystick</b></td>
    <td><b>Switch</b></td>
    <td><b>Data</b></td>
  </tr>
  <tr style="text-align:center">
    <td rowspan="5">0x2E</td>
    <td rowspan="6">1</td>
    <td>Up</td>
    <td>0xFE</td>
  </tr>
  <tr style="text-align:center">
    <td>Down</td>
    <td>0xFD</td>
  </tr>
  <tr style="text-align:center">
    <td>Left</td>
    <td>0xFB</td>
  </tr>
  <tr style="text-align:center">
    <td>Right</td>
    <td>0xF7</td>
  </tr>
  <tr style="text-align:center">
    <td>Fire</td>
    <td>0xEF</td>
  </tr>
  <tr style="text-align:center">
    <td>0x2D</td>
    <td>Arm</td>
    <td>0xEF</td>
  </tr>
  <tr style="text-align:center">
    <td rowspan="5">0x2B</td>
    <td rowspan="6">2</td>
    <td>Up</td>
    <td>0xFE</td>
  </tr>
  <tr style="text-align:center">
    <td>Down</td>
    <td>0xFD</td>
  </tr>
  <tr style="text-align:center">
    <td>Left</td>
    <td>0xFB</td>
  </tr>
  <tr style="text-align:center">
    <td>Right</td>
    <td>0xF7</td>
  </tr>
   <tr style="text-align:center">
    <td>Fire</td>
    <td>0xEF</td>
  </tr>
  <tr style="text-align:center">
    <td>0x27</td>
    <td>Arm</td>
    <td>0xEF</td>
  </tr>
</table>

<hr />

<h2><a name="diskcon">VZ200/300 DISK CONTROLLER</a></h2>

<p>This is a plug-in port-mapped device capable of supporting two X-7302 disk drives. The Disk Controller occupies the I/O address space from 10 Hex to 1F Hex of the port map. Effectively only 4 I/O locations are used to control and read back data from the Disk Drives.</p>

<table border="1" bgcolor="white">
  <tr>
    <td style="text-align:center"><b>I/O Address</b></td>
    <td><b>Function</b></td>
  </tr>
  <tr>
    <td rowspan="6" style="text-align:center">0x10</td>
    <td>Latch (write-only)</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 0-3 : Stepper-motor control phases (active HIGH)</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 4 : Drive 1 enable (active LOW)</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 5 : Write data (active HIGH)</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 6 : Write request (active LOW)</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 7 : Drive 2 enable (active LOW)</td>
  </tr>
  <tr>
    <td rowspan="2" style="text-align:center">0x11</td>
    <td>Data (read only)</td>
  </tr>
  <tr>
    <td>&nbsp; Bits 0-7 : Data byte read from disk</td>
  </tr>
  <tr>
    <td rowspan="3" style="text-align:center">0x12</td>
    <td>Polling (read only)</td>
  </tr>
  <tr>
    <td>&nbsp; Bits 0-6 : not used</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 7 : clock bit polling input</td>
  </tr>
  <tr>
    <td rowspan="3" style="text-align:center">0x13</td>
    <td>Write Protect Status</td>
  </tr>
  <tr>
    <td>&nbsp; Bits 0-6 : not used</td>
  </tr>
  <tr>
    <td>&nbsp; Bit 7 : 1=write-protect, 0=write-enabled</td>
  </tr>
</table>

<hr />
<a name="diskdrive"></a>

<h2>VZ200/300 DISK DRIVE</h2>

<p>The X-7302 VZ200/300 floppy disk drive consists of read/write, control and drive motor electronics, drive mechanism, read/write head, and track positioning mechanism. These components perform the following functions:</p>

<ul>
  <li>Receive and generate control signals</li>
  <li>Position of the read/write head to the desired track</li>
  <li>Read/write of data</li>
  <li>Control of drive motor speed</li>
</ul>

<h3>READ/WRITE and CONTROL ELECTRONICS</h3>

<p>The three electronic boards contain:</p>

<ul>
  <li>Stepper motor driver</li>
  <li>Write amplifier</li>
  <li>Read amplifier and control circuits</li>
  <li>File protect sensor</li>
  <li>Drive enable circuit</li>
  <li>Drive motor control circuit</li>
</ul>

<h4>DRIVE MECHANISM</h4>

<p>The drive motor rotates the spindle at 85 rpm through a beltdrive system. The speed of the motor is controlled by a tachofeedback servo circuit. A hub clamp that moves in conjunction with the door closure mechanism centres and clamps the floppy disk onto the spindle hub.</p>

<h4>R/W HEAD POSITIONING MECHANISM</h4>

<p>The R/W head is positioned to the desired track by applying the control signals to the stepper motor. The connection between the head carriage and the stepper motor is through a steel belt. The stepper motor rotates 2 steps per track.</p>

<h4>R/W HEAD</h4>

<p>The R/W head is used to read/write data to and from the floppy disk. The R/W head is mounted on the head carriage which moves on rails and is positioned by the stepper motor. The floppy disk is held on a plane perpendicular to the R/W head.</p>

<h4>TRACK 00 STOPPING MECHANISM</h4>

<p>After powering on and track location failure, the position of the R/W head is indeterminant. In order to assure proper positioning of the R/W head after powering on, a step-out operation (recalibration) is performed until it is locked at track 00 by the track 00 stopper.</p>

<h4>DRIVE SELECTION</h4>

<p>The drive is selected by activating the -BENBL line. After being selected, the drive motor and the LED on the front panel bezel will be on.</p>

<h4>FILE PROTECTION MECHANISM</h4>

<p>The file protect mechanism is constructed with a LED and phototransistor to detect the existence of the write enable notch of the disk jacket. When a disk with the notch covered is installed and the light passing for detection is disturbed, no write or erase current will flow through the R/W head. The recorded information on the disk is protected from an erroneous input of a write command.</p>

<h3>FUNCTION of TEST POINTS and VARIABLE RESISTORS</h3>

<p>The diagram below shows the mounting position of the test points and the variable resistors:</p>

<p><img src="fddtest.png" width="512" height="96"></p>

<h3>FUNCTION of TEST POINTS</h3>

<h4>i) TP1, TP3 PCBA Control and R/W amplifier.</h4>

<p>Test points for observing the read pre-amplifier output signals after passing through the low-pass filter. Hence TP1 and TP3 are used for the check and adjustment of the head seek mechanism. ie track alignment.</p>

<p>For observation of the read waveforms, use two channels of an oscilloscope with one channel set to INVERT mode and then ADD both channels. Use test point TP2 for the oscilloscope ground. This method will display full 'balanced' signal, if these modes are unavailable on oscilloscope then observe waveform using single oscilloscope channel from either TP1 or TP3 and TP2 as ground.</p>

<h4>ii) TP2, TP5 are both system ground terminals.</h4>

<h4>iii) TP6 is a test point for observing read data pulses.</h4>

<h4>iv) TP4 is not used.</h4>

<h3>FUNCTION of VARIABLE RESISTORS</h3>

<h4>i) VR1 PCBA control and R/W amplifier</h4>

<p>VR1 is used for adjusting peak shift of the read data.</p>

<h4>ii) VR2 PCBA drive motor</h4>

<p>VR2 is used for adjusting the rotational speed of the spindle.</p>

<h3>TROUBLESHOOTING GUIDE</h3>

<h4>TOOLS and EQUIPMENT</h4>

<ol>
  <li>Dual channel oscilloscope with Differential Mode input (ie ADD, INVERT), of 1OMHz or better</li>
  <li>Frequency counter</li>
  <li>VZ200/300 and Disk Controller</li>
  <li>Software: DISK CONTROL program (for controlling the stepping motor to move the R/W head for alignment and TRK 00 recalibration). Refer to suggested listing)</li>
  <li>DYSAN 48 TPI alignment disk. (#206-10)</li>
  <li>Cleaning disk (if available)</li>
  <li>Working disk</li>
  <li>Another VZ200/300 Disk Drive (used as working disk)</li>
  <li>Screwdrivers: PHILIPS screwdriver, 5mm; Blade screwdriver, 3mm</li>
  <li>Hexagon wrench key, 1.5mm</li>
  <li>Locking agent (eg. nail-polish)</li>
</ol>

<h4>GENERAL PROCEEDURE</h4>

<p>i) Remove the top and bottom cases by removing securing screws under unit.</p>

<p>ii) Set up the computer with the working drive as Drive 1 and the Drive under test as Drive 2.</p>

<p>iii) Connection and disconnection of connectors. Note-complete orientation and position of connectors before removing-them. Be sure to turn the power OFF before connecting or disconnecting the connectors. When plugging or removing connectors, this should be done without applying excessive force to the cables or post pins.</p>

<p>iv) If the LED on the front bezel is ON but the Drive Motor remains stationary, check that the connectors are securely connected.</p>

<h4>CHECK and ADJUSTMENT of DISK ROTATION SPEED.</h4>

<p>i) Install Alignment Disk in disk drive to be checked. Select DRIVE by typing DIR command.</p>

<p>ii) Use the Frequency Counter to monitor the output of test point TP1 (Ground on TP2).</p>

<p>iii) The reading of the frequency counter should be 35.417 kHz. If the frequency is off by more than 1 kHz (approx 3%) then adjust VR2 on the Drive Motor PCB.</p>

<p>iv) After checking that this measurement is satisfactory, fix VR2 with a small drop of locking agent.</p>

<h4>CHECK and ADJUST of TRACK ALIGNMENT</h4>

<p>i) connect two channels of the oscilloscope to TP1 and TP3 on the Control and R/W amplifier PCB.</p>

<p>ii) Oscilloscope setting:2OmS/division, CH.A and CH-B both AC mode .5V/division</p>

<p>iii) Set one Channel to INVERT and ADD both channels.</p>

<p>iv) Load the DISK DRIVE CONTROL program.</p>

<p>v) Install the Alignment disk in the Drive to be tested.</p>

<p>vi) Using the control program, send the head carriage to TRK 16.</p>

<p>vii) The lobe patterns displayed should be within 70% of each other, see diagram below. If they are, then no adjustment is required. If they are not, then proceed with adjustment.</p>

<p><img src="fddosc.png" width="512" height="240"></p>

<p>viii) Loosen the stepper-motor fixing screws and while observing the waveform, turn the stepper motor to correct the lobe pattern.</p>

<p>ix) Check that the adjustment is stable by stepping off TRK 16 in both directions and returning.</p>

<p>x) Once corrected and stable, tighten the stepper-motor fixing screws, and seal with a small amount of locking agent.</p>

<h4>CHECK of FILE PROTECT SENSOR</h4>

<p>i) Load Disk control Program</p>

<p>ii) Insert a work disk without a write-protect tab, halfway into the disk drive.</p>

<p>iii) Use the 'P' command to check the drive status. The message 'DISK IS WRITE PROTECTED' should appear.</p>

<p>iv) Now fully insert and close door, the message 'DISK IS NOT WRITE PROTECTED' should appear.</p>

<p>NOTE: If any of the above adjustments do not rectify the Disk Drive's problem, then return the Drive to a Dick Smith Service Dept for a detailed diagnosis.</p>

<h3>PREVENTIVE MAINTAINANCE</h3>

<p>If the DISK DRIVE is used in a dusty environment, it is suggested that a periodic cleaning is made of the magnetic-head suface.</p>

<p>i) Setup DISK DRIVE in position 2.</p>

<p>ii) If a CLEANING DISK is available, insert this and using the DISK CONTROL program move the R/W HEAD between track 00 and the innermost track several times.</p>

<p>iii) If CLEANING DISK is unavailable. Remove covers to gain access to R/W HEAD assembly.</p>

<p>iv) Use a cotton swab lightly dampened with pure alcohol. Carefully lift the HEAD LOAD PAD ARM and clean the R/W Head and surrounding area. Wipe the HEAD surface with a clean dry cloth after the alcohol has evaporated. Be sure to inspect the area for dirt or fluff left on the HEAD surface, before letting the HEAD LOAD PAD ARM down.</p>

<p>v) Reassemble and check for normal operation.</p>

<h3>LISTING OF DISK CONTROL PROGRAM</h3>

<code>
10 REM DISK CONTROL PROGRAM<br />
20 REM A. LATCH CONTROL -----<br />
30 REM I/O ADR:10H<br />
40 REM BIT 0 - BIT 3:<br />
50 REM STEPPER PHASE CONTROL<br />
60 REM BIT 4:DRIVE 1 ENABLE<br />
70 REM BIT 5:WRITE DATA<br />
80 REM BIT 6:WRITE REQUEST<br />
90 REM BIT 7:DRIVE 2 ENABLE<br />
100 REM DATA STROBE -----<br />
110 REM I/O'ADR: 11H<br />
120 BIT 0 - BIT 7:<br />
130 REM DATA BYTE READ FROM<br />
140 REM DISK DRIVE<br />
150 REM<br />
160 REM C. POLLING -----<br />
170 REM I/O ADR : 12H<br />
180 REM BIT 0 - BIT 6:<br />
190 REM NOT USED<br />
200 REM BIT 7: CLOCK BIT<br />
210 REM POLLING INPUT<br />
220 DIM D(4)<br />
230 CLS<br />
240 PRINT:PRINT TAB(6)"DISK CTRL PROGRAM"<br />
250 PRINT<br />
260 PRINT:PRINT TAB(6)"COMMANDS:"<br />
270 PRINT:PRINT TAB(6)"R RECALIBRATION"<br />
280 PRINT TAB(6)"G GOTO TRACK<br />
290 PRINT TAB(6)"I STEP IN<br />
300 PRINT TAB(6)"O STEP OUT<br />
310 PRINT TAB(6)"P CHECK WRITE PROTECT"<br />
320 PRINT TAB(6)"Q QUIT"<br />
330 PRINT:INPUT "COMMAND ";A$<br />
340 IF A$="R" THEN GOSUB 410<br />
350 IF A$="I" THEN GOSUB 560<br />
360 IF A$="O" THEN GOSUB 700<br />
370 IF A$="G" THEN GOSUB 900<br />
380 IF A$="Q" THEN GOSUB 870<br />
390 IF A$="P" THEN GOSUB 1070<br />
400 GOTO 330<br />
410 REM - RECALIBRATE R/W HEAD<br />
420 P=O<br />
430 OUT 16,192<br />
440 FOR J=l To 24<br />
450 FOR I=3 TO 0 STEP -1<br />
460 D(I)=l:GOSUB 1050<br />
470 OUT 16,192+LA<br />
480 D(I)=O:GOSUB 1050<br />
490 OUT 16,192+LA<br />
500 NEXT<br />
510 NEXT<br />
520 D(O)=l:D(1)=O:D(2)=O:D(3)=O<br />
530 OUT 16,193<br />
540 TC=O<br />
550 GOSUB 840:RETURN<br />
560 REM MOVE THE R/W HEAD TO<br />
570 REM INNER TRACKS<br />
580 IF TC=39.5 THEN RETURN<br />
590 D(P/2)=O<br />
600 GOSUB 1050<br />
610 OUT 16,192+LA<br />
620 P=P+2<br />
630 IF P=8 THEN P=O<br />
640 D(P/2)=l<br />
650 GOSUB 1050<br />
660 OUT 16,192+LA<br />
670 TC=TC+.5<br />
680 GOSUB 840<br />
690 RETURN<br />
700 REM - MOVE THE R/W HEAD<br />
710 REM TO THE OUTER TRACKS<br />
720 IF TC=O THEN RETURN<br />
730 D(P/2)=O<br />
740 GOSUB 1050<br />
750 OUT 16,192+LA<br />
760 P=P-2<br />
770 IF P=-2 THEN P=6<br />
780 D(P/2)=l<br />
790 GOSUB 1050<br />
800 OUT 16,192+LA<br />
810 TC=TC-.5<br />
820 GOSUB 840<br />
830 RETURN<br />
840 REM - SHOW TRACK NUMBER<br />
850 PRINT "TRACK = ";TC<br />
860 RETURN<br />
870 REM - EXIT THE PROGRAM<br />
880 OUT 16,40:END<br />
890 REM - MOVE THE R/W HEAD TO THE DESIRED TRACK<br />
900 INPUT "ENTER TRACK NUMBER =";TN<br />
910 IF (TN&gt;39.5) OR (TN&lt;O) THEN GOTO 900<br />
920 TT=TN-TC<br />
930 IF TT&lt;=O THEN 990<br />
940 TT=TT*2<br />
950 FOR CN=l TO TT<br />
960 GOSUB 560<br />
970 NEXT<br />
980 RETURN<br />
990 IF TT=TC THEN RETURN<br />
1000 TT=TT*(-2)<br />
1010 FOR CN=l TO TT<br />
1020 GOSUB 560<br />
1030 NEXT<br />
1040 RETURN<br />
1050 IA=D(3)*8+D(2)*4+D(1)*2+D(O)<br />
1060 RETURN<br />
1070 WP=INP(19)<br />
1080 IF WP&gt;127 THEN PRINT "DISK IS WRITE-PROTECTED"<br />
1090 IF WP&lt;128 THEN PRINT "DISK IS NOT WRITE-PROTECTED"<br />
1100 RETURN
</code>

<hr />

<h2><a name="screencodes">VZ200/300 SCREEN CONTROL CODES</a></h2>

<p>The following codes can be used for screen control from BASIC:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td>Cursor left</td>
    <td>PRINTCHR$(8)</td>
  </tr>
  <tr style="text-align:center">
    <td>Cursor right</td>
    <td>PRINTCHR$(9)</td>
  </tr>
  <tr style="text-align:center">
    <td>Cursor up</td>
    <td>PRINTCHR$(27)</td>
  </tr>
  <tr style="text-align:center">
    <td>Cursor down</td>
    <td>PRINTCHR$(10)</td>
  </tr>
  <tr style="text-align:center">
    <td>Rubout</td>
    <td>PRINTCHR$(127)</td>
  </tr>
  <tr style="text-align:center">
    <td>Insert</td>
    <td>PRINTCHR$(21)</td>
  </tr>
  <tr style="text-align:center">
    <td>Home</td>
    <td>PRINTCHR$(28)</td>
  </tr>
  <tr style="text-align:center">
    <td>Clear screeb</td>
    <td>PRINTCHR$(31)</td>
  </tr>
</table>

<hr />

<h2><a name="sysptrs">VZ200/300 SYSTEM POINTERS AND VARIABLE STORAGE LOCATIONS</a></h2>

<table border="1" bgcolor="white">
  <tr>
    <td rowspan="2"><b>&nbsp;POINTER or VARIABLE</b></td>
    <td colspan="2" style="text-align:center"><b>Memory Address</b></td>
  </tr>
  <tr>
    <td style="text-align:center"><b>HEX</b></td>
    <td style="text-align:center"><b>DECIMAL</b></td>
  </tr>
  <tr>
    <td>Top of Memory (ptr)</td>
    <td style="text-align:center">0x78B1/2</td>
    <td style="text-align:center">30897/8</td>
  </tr>
  <tr>
    <td>Start of BASIC program (ptr)</td>
    <td style="text-align:center">0x78A4/5</td>
    <td style="text-align:center">30884/5</td>
  </tr>
  <tr>
    <td>End of BASIC program (ptr)<br />(also start of simple variable table)</td>
    <td style="text-align:center">0x78F9/A</td>
    <td style="text-align:center">30969/70</td>
  </tr>
  <tr>
    <td>Start of dim. variable table (ptr)</td>
    <td style="text-align:center">0x78FB/C</td>
    <td style="text-align:center">30971/2</td>
  </tr>
  <tr>
    <td>End of BASIC's stack (ptr)<br />(also start of string variable storage area)</td>
    <td style="text-align:center">0x78A0/1</td>
    <td style="text-align:center">30880/1</td>
  </tr>
  <tr>
    <td>Execute Address for USR program (ptr)<br />(NOTE: high byte of address must go in 788F)</td>
    <td style="text-align:center">0x788E/F</td>
    <td style="text-align:center">30862/3</td>
  </tr>
  <tr>
    <td>Interupt exit (called upon interupt)</td>
    <td style="text-align:center">0x787D/E/F</td>
    <td style="text-align:center">30845/6/7</td>
  </tr>
  <tr>
    <td>Start of BASIC line input buffer<br />(buffer is64 bytes long - 2 screen lines)</td>
    <td style="text-align:center">0x79E8</td>
    <td style="text-align:center">31208</td>
  </tr>
  <tr>
    <td>Copy of output latch</td>
    <td style="text-align:center">0x783B</td>
    <td style="text-align:center">30779</td>
  </tr>
  <tr>
    <td>Cursor position</td>
    <td style="text-align:center">0x78A6</td>
    <td style="text-align:center">30886</td>
  </tr>
  <tr>
    <td>Output device code<br />0=video, 1=printer, -1=cassette</td>
    <td style="text-align:center">0x789C</td>
    <td style="text-align:center">30876</td>
  </tr>
</table>

<p>The contents of the BASIC stack pointer stored in 78A0/l are basically equal to the contents of the 'top of memory' pointer stored in 78Bl/2, less a figure equal to the number of bytes reserved for string storage. The default value for string storage space is 50 bytes; this can be modified from within a basic program by using the CLEAR command - ie CLEAR 1000 will increase the string space to store 1000 bytes.</p>

<p>The VZ200/300 printer interface uses I/O port address OE Hex for the ASCII character code data and strobe output, and address OOH for the busy/ready-bar status input (bit 0).</p>

<a name="machinecode"></a>

<h2>RESERVING SPACE FOR A MACHINE CODE PROGRAM</h2>

<p>There are a number of ways to reserve memory space for a machine code program, from within a BASIC program. But before details of these methods are given, we should clarify the way BASIC normally organizes memory space.</p>

<p>A range of addresses at the bottom of user RAM is reserved for system pointers and variables. This section is often termed the communications region'. It includes locations which store pointers to the boundaries of the various regions in upper RAM, like the 'Top of Memory' pointer, the 'Start of BASIC program' pointer and so on. The latter pointer is stored at 78A4/5 Hex (30884/5 Decimal).</p>

<p>Normally the BASIC program itself is stored next, in locations starting at address 7AE9 Hex. At the end of the BASIC program text, the system stores a table containing the program's variables. This is known as the 'variable list table' (VLT). This is divided into two sections: first, the simple variable table containing simple numeric variables and pointers to the simple string variables, and second - the subscripted variable table containing dimensioned variables.</p>

<p>As the BASIC program text changes in length, the VLT is moved up or down in memory so that it always begins from the end of the BASIC program. The pointer to the start of the VLT is stored in location 78F9/A, and the pointer to the start of the subscripted variable table in location 78FB/c.</p>

<p>The remaining major regions extend downward from the top of user RAM. Normally at the very top of RAM is the string storage area, extending down from the top of RAM (pointer stored at 78Bl/2) by either the default figure of 50 bytes, or a different amount established by the CLEAR N command. The BASIC interpreter's stack then extends downward in memory from the bottom of the string area (pointer stored in 78AO/1). The space between the top of the VLT region and the bottom of the stack is not used, and is designated 'free' space So that normally, the RAM organization looks like this:</p>

<p><img src="BASICmap.png" width="480" height="192"></p>

<h3>METHOD 1:</h3>

<p>This method of reserving space for a machine code program involves shifting the BASIC program area upward in memory from its normal start at 7AE9, creating a space immediately above the communications region. The machine code program can then be loaded into this space, probably by POKEing it from your main BASIC program.</p>

<p>Needless to say, the BASIC program area can only be shifted up <u>before</u> your main program is loaded into it (if it were done afterwards, the start of the program would be lost). But the shifting is quite easy to do, because all that is required is A) change the 'Start of BASIC program' and 'End of Program/Start of VLT' pointers, together with B) creation of a new 'null program' at the start of the new program area.</p>

<p>This can be done quite easily from a small BASIC program which is fed into the computer ahead of your main program. Here is what it looks like if you want to reserve say 128 bytes:</p>

<code>
10 POKE 31593,0:POKE 31594,0:POKE 31595,0<br />
20 POKE 30884,105:POKE 30885,123<br />
30 POKE 30969,107:POKE 30970,123
</code>

<p>Here, line 10 pokes a 'null program' of 3 zero bytes into the start of the new program area (which starts at 7B69H or 31593). Line 20 pokes the decimal equivalents of the low and high bytes of this new starting address of the program area into its pointer address, while line 30 pokes in the corresponding values for the EOP/VLT pointer.</p>

<p>Note that this shifting program 'self-destructs' - once you run it, the BASIC interpreter loses all knowledge of its existence in memory. So if you then try to LIST or RUN, nothing will happen, because as far as the interpreter is concerned, it now has nothing in its (new) program storage area.</p>

<p>Once the program has run, however, any BASIC program loaded will start at the new, higher address (here, 128 bytes up), leaving the space immediately above the communications area free for a machine language routine or program.</p>

<p>Needless to say you can vary the above program to adjust the amount of space reserved. You'll need to change both the values poked into the pointer locations in lines 20 and 30, and the poke addresses in line 10.</p>

<p>Don't forget that if you use this method, the 'reserving' program will have to be loaded an ' d run ahead of the main program every time you want to use it. The reserving operation can't be done from within the main program itself.</p>

<p>This is one disadvantage of this method; another is that it is not easy to load in your main BASIC program and the machine language program directly from tape.</p>

<h3>METHOD 2:</h3>

<p>With this method of reserving space for a machine language program,, you create the required space in between the end of the main BASIC program and the start of the VLT, by shifting the VLT upward in memory.</p>

<p>This is simpler to achieve than method 1, because all that is required is to change the 'End of BASIC program/start of VLT' pointer stored in 78F9/A Hex (decimal 30969/70). In effect, we 'fool' the BASIC interpreter into thinking that the BASIC program is longer than it really is.</p>

<p>How do you work out this hew value for the EOP/VLT pointer? Probably the best way is to PEEK at the value of the pointer when your main program is loaded in normally, and then add to this figure the amount you need for your machine language routine plus a small amount (say 64 bytes) for a safety margin.</p>

<p>Let's say again you want to reserve 128 bytes. First load in your main basic program, then key in this command:</p>

<code>
PRINT PEEK(30969) + 256*PEEK(30970)
</code>

<p>The answer you get is the current value of the EOP/VLT pointer, in decimal. In other words it represents the <u>actual</u> end of your BASIC program. So add say 192 to this (128 plus a saftey margin), to get the new EOP/VLT pointer value.</p>

<p>Say the value you get is 32800. Now find the decimal equivalents of the high and low pointer bytes for this figure, by keying in this line:</p>

<code>
P=32800:PRINT INT(P/256),P-(256*INT(P/256))
</code>

<p>The first number you get is the pointer high byte (in this case 128), while the second is the pointer low byte (here 32). obviously if you get a different value from 32800, key this into the above line to get the corresponding values.</p>

<p>Now all you have to do is fit these values into a pair of POKE statements at the very start of your main BASIC program:</p>

<code>
1 POKE 30969,32:POKE 30970,128
</code>

<p>This line must be right at the start of your program, so that the EOP/VLT pointer is <u>moved</u> before the program introduces or uses any variables. Otherwise the variables would be 'lost'.</p>

<p>This method allows you to load save and run the BASIC program normally, without any prior preparation. once you have loaded the machine language program into the reserved space between the BASIC program and its VLT, you can also save and re-load it along with the BASIC program.Note that the 64 byte 'safety margin' allows for the small increase in program length when you add line 1 above.</p>

<h3>Method 3:</h3>

<p>This method of reserving space for a machine language program involves changing the 'Top of Memory' (TOM) pointer so that it points to an address lower than the actual top of memory. This forces the BASIC interpreter to move its string storage area and stack downward, leaving a space for your machine language program at the top. Like Method 2, this is quite easy to do and it can be done from within your BASIC program.</p>

<p>First, you need to PEEK the current value of the TOM pointer. This is found quite easily by:</p>

<code>
PRINT PEEK(30897) + 256*PEEK(30898)
</code>

<p>ie. This will give you 36863 for a basic VZ200 (53247 for a VZ200 with 16k expanded memory).</p>

<p>Then you simply subtract from this figure the amount of space you want to reserve for the machine language program, to give a new TOM address. Then it's simply a matter of poking the low and high byte figures for this address into the TOM pointer, at the start of your program.</p>

<p>For example, say you want to reserve 256 bytes, and you have a basic VZ200 so the normal TOM is 36863. So the new artificial TOM will be 36863-256, giving 36607. To work out the two new pointer bytes in decimal type in :</p>

<code>
T=36607:PRINT INT(T/256),T-(256*INT(T/256))
</code>

<p>The first number you get is the pointer high byte (here, 142), while the second is the low byte (here 255). If you have a different value of TOM (for the VZ300 for example), you will get corresponding values.</p>

<p>Having found these values all you need do is add the following line to the start of your program:</p>

<code>
1 POKE 30897,255:POKE 30898,142
</code>

<p>The pointer must be changed before the program uses string variables or the stack, otherwise the system could 'crash'.</p>

<p>Note that this method allows your BASIC program to be loaded, saved and run normally. However it does not allow the machine language program to be loaded directly into the reserved area at the same time. The machine code must be loaded either separately, or POKED into the reserved area by the BASIC program itself after the pointer is changed.</p>

<h3>FINDING THE TOP OF YOUR VZ200/300's MEMORY</h3>

<p>This is somewhat more simple - type in the line:</p>

<code>
PRINT PEEK(30897) + 256*PEEK(30898)
</code>

<h3><a name="machineroutines">CALLING A MACHINE CODE ROUTINE FROM BASIC</a></h3>

<p>The standard way of calling a machine language program or routine from BASIC is to use the USR(X) command. But before this command can be used, the starting address of the machine language routine must be loaded into the USR program pointer, stored at address 788E/F Hex (decimal 30862/3). This can be done using POKE statements.</p>

<p>As it happens, the BEEP subroutine in the VZ200/300's BASIC ROM can easily be called to do this, using the USR(X) command. The calling address for the routine is 3450 Hex, so the decimal figures for the USR pointer bytes are 80 (low byte, equal to 50 Hex) and 52 (high byte, equal to 34 Hex).</p>

<p>So if you want to produce a "beep" at various places in your BASIC program, all you need to do is put this line near the start of the program (before the first beep is needed).</p>

<code>
20 POKE 30862,80:POKE 30863,52
</code>

<p>This sets up the USR pointer. Then, whenever a "beep" is required in the program, simply use the command:</p>

<code>
X=USR(X)
</code>

<p>Note that before control is passed to the user routine at the designated address, the value of the argument variable X is stored in locations 31009/31010 (7921/2 Hex). So this can be used to 'pass' a parameter value to the user routine. If the routine doesn't need any parameters (like the "beep" routine above), simply use a 'dummy' variable name like X, as shown.</p>

<p>The same general technique is used for calling other machine language routines, whether they are located in ROM or RAM. It's simply a matter of poking the start address of the routine into 30862/3, and then using the USR command.</p>

<p>You aren't limited to calling a single machine code routine. You can call a number of routines in turn, simply by poking each routine's start address into 30862/3 before you use the USR command to call it. Just remember to POKE the right routine address into the pointer each time!</p>

<h3><a name="romsubs">USEFUL ROM SUBROUTINES FOR ASSEMBLY PROGRAMMING</a></h3>

<h4>KEYBOARD SCANNING ROUTINE</h4>

<p>The keyboard scanning routine resides at 2EF4 hex. This routine scans the keyboard once and returns. If a key is pressed, the A register will contain the code for that key; otherwise this register will contain zero. Registers AF, BC, DE and HL are all modified by the routine, so if the contents of these registers must be preserved they should be pushed onto the stack before the routine is called. The following example shows how the routine would be used to wait for the RETURN key to be pressed:</p>

<table cellpadding="2">
  <tr>
    <td>SCAN</td>
    <td>CALL</td>
    <td>2EF4H</td>
    <td>;scan keyboard once</td>
  </tr>
  <tr>
    <td></td>
    <td>OR</td>
    <td>A</td>
    <td>;any key pressed?</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>Z,SCAN</td>
    <td>;back if not</td>
  </tr>
  <tr>
    <td></td>
    <td>CP</td>
    <td>0DH</td>
    <td>;was it RETN key?</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>NZ,SCAN</td>
    <td>;back if not</td>
  </tr>
  <tr>
    <td></td>
    <td>...</td>
    <td></td>
    <td>;otherwise continue</td>
  </tr>
</table>

<h4>CHARACTER OUTPUT SUBROUTINE</h4>

<p>A routine which outputs a single character to the video display is located at 033A Hex. The code for the character to be displayed must be in the A register, while the character will be displayed on the screen at the position corresponding to the current value of the cursor pointer. All registers are preserved. Here is how the routine is called to display the word "HI" followed by a carriage return:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>LD</td>
    <td>A,'H'</td>
    <td>;load reg A with code</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>033AH</td>
    <td>;display it</td>
  </tr>
  <tr>
    <td></td>
    <td>LD</td>
    <td>A,'I'</td>
    <td>;load reg A with next code</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>033AH</td>
    <td>;display it</td>
  </tr>
  <tr>
    <td></td>
    <td>LD</td>
    <td>A,0DH</td>
    <td>;load reg A with CR code</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>033AH</td>
    <td>;update the screen</td>
  </tr>
</table>

<h4>MESSAGE OUTPUT SUBROUTINE</h4>

<p>A very useful subroutine located at 28A7 hex can display a string of character codes as a message on the screen. The string of character codes must end with a zero byte. The HL register pair must be set to the start of the string before the subroutine is called. All registers are used by the subroutine. Here is how it is used:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>LD</td>
    <td>HL,MSG</td>
    <td>;load HL with start of string</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>28A7H</td>
    <td>;and call print subroutine</td>
  </tr>
  <tr>
    <td></td>
    <td>...</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>MSG</td>
    <td>DEFM</td>
    <td>'READY'</td>
    <td>;main message string</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>0DH</td>
    <td>;carriage return</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>0</td>
    <td>;null byte to terminate</td>
  </tr>
</table>

<h4>COMPARE SYMBOL (EXAMINE STRING) - RST 08H</h4>

<p>A routine which is called using the RST 08H instruction can be used to compare a character in a string pointed to by the HL register, with the value in the location following the RST 08H instruction itself. If there is a match, control is returned to the instruction 2 bytes after the RST 08H, with the HL register incremented by 1 and the next character of the string in the A register. This allows repeated calls to check for an expected sequence of characters. Note that if a match is not found, the RST 08H routine does not return from where it is called, but jumps instead to the BASIC interpreter's input phase after ' printing the "SYNTAX ERROR" message. Here is how the routine is used to check that the string pointed to by HL register is "A=B=C":</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;test for value 'A'</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>41H</td>
    <td>;hex value of 'A' for comparison</td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;must have found, so try for '='</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>3DH</td>
    <td>;hex value of '='</td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;OK s far, try for 'B'</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>42H</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;now look for second '='</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>3DH</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;finally check for 'C'</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>43H</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>...</td>
    <td></td>
    <td>must have been OK so proceed</td>
  </tr>
</table>

<h4>LOAD &amp; CHECK NEXT CHARACTER IN STRING -- RST 10H</h4>

<p>The RST 10H instruction may be used to call a routine which loads the A register with the next character of a string pointed to by the HL register, and clears the CARRY flag if character is alphanumeric. Blanks and control codes 09H and OBH are skipped automatically. The HL register is incremented before each character is loaded, therefore on the first call the HL register should be set to point to the address BEFORE the location of the first string character to be tested. The string must be terminated by a null byte.</p>

<p>Here is an example of this routine in use. Note that if it is used immediately after the RST 08H instruction as shown, the HL register will automatically be incremented to point to the next character in the string:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>RST</td>
    <td>08H</td>
    <td>;test for '='</td>
  </tr>
  <tr>
    <td></td>
    <td>DEFB</td>
    <td>3DH</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>10H</td>
    <td>;fetch &amp; check next char</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>NC,VAR</td>
    <td>;will go to VAR if alpha</td>
  </tr>
  <tr>
    <td></td>
    <td>...</td>
    <td></td>
    <td>;continues if numeral</td>
  </tr>
</table>

<h4>COMPARE DE &amp; HL REGISTER PAIRS - RST 18H</h4>

<p>The instruction RST 18H may be used to call a routine which compares the contents of the DE and HL register pairs. The routine uses the A register only, but will only work for unsigned or positive numbers. Upon returning, the result of the comparison will be in the status register:</p>

<table border="1" bgcolor="white">
  <tr style="text-align:center">
    <td>HL &lt; DE</td>
    <td>carry set</td>
  </tr>
  <tr style="text-align:center">
    <td>HL &gt; DE</td>
    <td>no carry</td>
  </tr>
  <tr style="text-align:center">
    <td>HL &lt;&gt; DE</td>
    <td>NZ</td>
  </tr>
  <tr style="text-align:center">
    <td>HL = DE</td>
    <td>Z</td>
  </tr>
</table>

<p>Here is an example of its use. Assume the DE pair contains a number and we want to check that it falls within a certain range - say between 100 and 500 (decimal):</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>LD</td>
    <td>HL,500</td>
    <td>;load HL with upper limit</td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>18H</td>
    <td>;&amp; call comparison routine</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>C,ERR</td>
    <td>;carry means num &gt; 500</td>
  </tr>
  <tr>
    <td></td>
    <td>LD</td>
    <td>HL,100</td>
    <td>;now set for lower limit</td>
  </tr>
  <tr>
    <td></td>
    <td>RST</td>
    <td>18H</td>
    <td>;&amp; try again</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>NC,ERR</td>
    <td>;no carry means num &lt; 100</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>...</td>
    <td>;if still here, must be OK</td>
  </tr>
</table>

<h4>SOUND DRIVER</h4>

<p>Located at 345C hex is a routine which can be used to produce sounds via the VZ200/300's internal piezo speaker. Before calling the routine, the HL register pair must be loaded with a number representing the pitch (frequency) of the tone to be produced, while the BC register pair must be loaded with the number of cycles of the tone required (ie the duration in cycles). All registers are used. The frequency coding used is inversely proportional to frequency, ie the smaller the number loaded into the HL register pair, the higher the frequency. As a guide, the low C produced by the VZ200/300's SOUND command in BASIC can be produced using the decimal number 526, the middle C using 529 and the high C using 127. Here is how you would use the routine to get say 75 cycles of the middle C:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>LD</td>
    <td>HL,259</td>
    <td>;set frequency code</td>
  </tr>
  <tr>
    <td></td>
    <td>LD</td>
    <td>BC,75</td>
    <td>;set number of cycles</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>345CH</td>
    <td>;&amp; call sound routine</td>
  </tr>
</table>

<h4>"beep" ROUTINE</h4>

<p>The routine which is used by BASIC to produce the short "beep" when a key is pressed is located at the address 3450 hex. It disturbs all registers except the HL pair. To make a beep:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>CALL</td>
    <td>3450H</td>
    <td>;make a "beep"</td>
  </tr>
</table>

<h4>CLEAR SCREEN</h4>

<p>A routine located at 0lC9 hex may be used to clear the video screen, home the cursor and select display mode (0). it disturbs all registers. Again it is used by simply calling it.</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>CALL</td>
    <td>01C9H</td>
    <td>;clear screen, home cursor, etc.</td>
  </tr>
</table>

<h4>PRINTER DRIVER</h4>

<p>The printer driver routine is located at 058D hex. To send a character to the printer, load the chracter's ASCII code into the C register and call the driver - After printing, the character code will be returned in both the A and C registers. All other registers are disturbed. For example to print the letter 'A' (ASCII code 97 decimal), you would use:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>LD</td>
    <td>C,97</td>
    <td>;set up code in C register</td>
  </tr>
  <tr>
    <td></td>
    <td>CALL</td>
    <td>058DH</td>
    <td>;&amp; call printer driver</td>
  </tr>
</table>

<p>A line feed character (OAH) is automatically inserted after a carriage return (ODH). If the driver is called with a null byte in the C register, it will simply check the printer status and return with bit 0 of the A register either set or cleared. The routine does check for a BREAK key depression, and if one is detected, it will return with the carry flag set.</p>

<h4>CHECK PRINTER STATUS</h4>

<p>A routine to check printer status is located at 05C4 hex. When called it loads the printer status (I/O port 00H) into the A register and returns. Bit 0 will be set (1) if the printer is busy, or cleared (0) if it is ready. No other registers are disturbed. An example:</p>

<table cellpadding="2">
  <tr>
    <td>TEST</td>
    <td>CALL</td>
    <td>054CH</td>
    <td>;check is printer ready</td>
  </tr>
  <tr>
    <td></td>
    <td>BIT</td>
    <td>0,A</td>
    <td>;test bit 0</td>
  </tr>
  <tr>
    <td></td>
    <td>JR</td>
    <td>NZ,TEST</td>
    <td>;loop if busy, continue if ready</td>
  </tr>
</table>

<h4>SEND CR-LF TO PRINTER</h4>

<p>A routine located at 03AE2 hex may be used to send a carriage return and line feed combination to the printer. No registers need be set up before calling, but all registers are disturbed. If the break key is pressed while printing occurs (or while the printer driver is waiting for the printer to signal 'ready'), the routine will return with the carry flag set:</p>

<table cellpadding="2">
  <tr>
    <td></td>
    <td>CALL</td>
    <td>3AE2H</td>
    <td>;go send CR-LF to printer</td>
  </tr>
  <tr>
    <td></td>
    <td>JP</td>
    <td>C,BRK</td>
    <td>;check if BREAK key is pressed</td>
  </tr>
  <tr>
    <td></td>
    <td>...</td>
    <td></td>
    <td>;aparrently not</td>
  </tr>
</table>

<hr />

<h2><a name="vzdos">VZ200/300 DISK OPERATING SYSTEM (DOS) ANALYSIS</a></h2>

<p>Information is included here to describe the operation and structure of the VZ200/300 DOS. The information will cover the format of the diskette, the recording technique, the DOS entry points and the structure of the DOS. It can be used to allow direct assembly language access to the DOS, and also to allow advanced programmers to enhance their DOS.</p>

<h3>DISKETTE FORMATTING</h3>

<p>The VZ200/300 DOS initializes the diskette into 40 tracks, with 16 sectors per track. They number from 0 to 39, track 00 being the outermost track and track 39 the innermost, The stepper motor (which moves the R/W-head arm) can position the disk arm over 80 'phases'. To move the arm from one track to the next, two phases of the stepper motor must be cycled. The DOS uses only even phases. Programmers may use this feature to generate protected disks by using odd phases or combinations of the two, provided that no two tracks are closer than two phases from one another. See the section on the disk controller I/O addresses for the control of the stepping motor.</p>

<p>The DOS subdivides the track into 16 sectors. It is the smallest unit of 'updatable' data on the diskette. The DOS reads or writes a sector at a time. This is to avoid using a large chunk of memory for a buffer to read or write an entire track. The DOS uses 'soft sectoring' to divide a track into 16 sectors without the use of the INDEX hole of the disk. Each sector may contain 128 bytes of data, sectors are arranged into a 2-sector interleave sequence to reduce the access time. The sequence of the sector arrangement is: 0, 11, 6, 1, 12, 7, 2, 13, 8, 3, 14, 9, 4, 15, 10, 5. Each sector is subdivided into fields. See the following diagram for the structure of a sector and a track.</p>

<h3>SECTOR FORMAT</h3>

<p><img src="fddformat.png" width="512" height="240"></p>

<h3>TRACK FORMAT (above)</h3>

<h3>RECORDING TECHNIQUE</h3>

<p>The VZ200/300 DOS uses the recording technique of FM (frequency modulation) to write data on the diskette. In FM format, each data bit is enclosed within a bit cell. When data is read back from the diskette it takes the form of the following diagram.</p>

<p><img src="fddtimingA.png" width="480" height="128"></p>

<p>As the diagram shows, the data bits (if present) are interleaved. The presence of a data bit between two clock bits represents a binary 1, the absence of a data bit between two clock bits represents a binary 0. The timing of each bit cell is shown below:</p>

<p><img src="fddtimingB.png" width="480" height="128"></p>

<p>In the DOS the length of each cell is 32.2uS with the data bit appearing 13uS behind the clock bit.</p>

<p>Due to the low signal transfer rate, the spindle rotation speed is reduced from 300 RPM (as in other drives) to 85 RPM to keep a high recording capacity.</p>

<h3>THE STRUCTURE OF THE DOS</h3>

<p>The DOS is a ROM based DOS which is located in 4000H to 5FFFH. When the computer is powered up, the BASIC interpreter will jump to the DOS after initializing the BASIC pointers. The DOS will reserve a DOS vector of 310 bytes at the top of memory available. The DOS vector is pointed to by the index register IY and this vector is used to keep track of all DOS operations. Programmers should avoid modifying the IY register, otherwise the DOS will probably crash.</p>

<p>The DOS vectors contain the following elements:</p>

<table border="1" bgcolor="white">
  <tr>
    <td><b>Name</b></td>
    <td><b>Bytes</b></td>
    <td><b>Offset</b></td>
    <td><b>Function</b></td>
  </tr>
  <tr>
    <td>FILNO</td>
    <td>1</td>
    <td>IY+0</td>
    <td>File Number</td>
  </tr>
  <tr>
    <td>FNAM</td>
    <td>8</td>
    <td>IY+1</td>
    <td>Filename</td>
  </tr>
  <tr>
    <td>TYPE</td>
    <td>2</td>
    <td>IY+9</td>
    <td>File type</td>
  </tr>
  <tr>
    <td>DK</td>
    <td>1</td>
    <td>IY+11</td>
    <td>Selected drive# pattern</td>
  </tr>
  <tr>
    <td>RQST</td>
    <td>1</td>
    <td>IY+12</td>
    <td>Request code</td>
  </tr>
  <tr>
    <td>SOURCE</td>
    <td>1</td>
    <td>IY+13</td>
    <td>Source drive for DCOPY</td>
  </tr>
  <tr>
    <td>UFBR</td>
    <td>2</td>
    <td>IY+14</td>
    <td>User buffer address</td>
  </tr>
  <tr>
    <td>DESTIN</td>
    <td>1</td>
    <td>IY+16</td>
    <td>Destination drive for DCOPY</td>
  </tr>
  <tr>
    <td>SCTR</td>
    <td>1</td>
    <td>IY+17</td>
    <td>User spec. sector number</td>
  </tr>
  <tr>
    <td>TRCK</td>
    <td>1</td>
    <td>IY+18</td>
    <td>User spec. track number</td>
  </tr>
  <tr>
    <td>RETRY</td>
    <td>1</td>
    <td>IY+19</td>
    <td>Retry count</td>
  </tr>
  <tr>
    <td>DTRCK</td>
    <td>1</td>
    <td>IY+20</td>
    <td>Current track number</td>
  </tr>
  <tr>
    <td>NSCT</td>
    <td>1</td>
    <td>IY+21</td>
    <td>Next sector number</td>
  </tr>
  <tr>
    <td>NTRK</td>
    <td>1</td>
    <td>IY+22</td>
    <td>Next track number</td>
  </tr>
  <tr>
    <td>FCB1</td>
    <td>13</td>
    <td>IY+23</td>
    <td>File control block 1<br />OPEN flag, STATUS, FNAM TRK#, SCTR#, Entry in sector</td>
  </tr>
  <tr>
    <td>FCB2</td>
    <td>13</td>
    <td>IY+36</td>
    <td>File control block 2<br />OPEN flag, STATUS, FNAM TRK#, SCTR#, Entry in sector</td>
  </tr>
  <tr>
    <td>DBFR</td>
    <td>2</td>
    <td>IY+49</td>
    <td>Data buffer address</td>
  </tr>
  <tr>
    <td>LTHCPY</td>
    <td>1</td>
    <td>IY+51</td>
    <td>Copy of latch</td>
  </tr>
  <tr>
    <td>MAPADR</td>
    <td>2</td>
    <td>IY+52</td>
    <td>Track/Sector map address</td>
  </tr>
  <tr>
    <td>TRKCNT</td>
    <td>1</td>
    <td>IY+54</td>
    <td>Track count for DCOPY</td>
  </tr>
  <tr>
    <td>TRKPTR</td>
    <td>1</td>
    <td>IY+55</td>
    <td>Track pointer for DCOPY</td>
  </tr>
  <tr>
    <td>PHASE</td>
    <td>1</td>
    <td>IY+56</td>
    <td>Stepper phase</td>
  </tr>
</table>

<h3>DISK STRUCTURE</h3>

<p>The DOS uses TRK 0, sector 0 to sector 14 as the directory. TRK 0 sector 15 is used to hold the track map of the disk with one bit corresponding to a sector used. Each directory entry contains 16 bytes. Therefore 1 sector can hold 8 entries and 1 diskette can have a maximum of 112 entries.</p>

<table border="1" bgcolor="white">
  <tr>
    <td>File Type</td>
    <td>1 byte</td>
  </tr>
  <tr>
    <td>Delimeter (0x3A)</td>
    <td>1 byte</td>
  </tr>
  <tr>
    <td>File Name</td>
    <td>8 bytes</td>
  </tr>
  <tr>
    <td>Start Address</td>
    <td>2 bytes</td>
  </tr>
  <tr>
    <td>End Address</td>
    <td>2 bytes</td>
  </tr>
  <tr>
    <td>Start Track #</td>
    <td>1 byte</td>
  </tr>
  <tr>
    <td>Start Sector #</td>
    <td>1 byte</td>
  </tr>
</table>

<h3>DOS ENTRY POINTS</h3>

<p>A jump table to the DOS subroutines is positioned at the fixed address from 4008H to 4044H. The jump table contains the following elements:</p>

<table cellpadding="2">
  <tr>
    <td><b>Address</b></td>
    <td><b>Content</b></td>
    <td><b>DOS Subroutine</b></td>
  </tr>
  <tr>
    <td>0x4008</td>
    <td>JP PWRON</td>
    <td>Disk power on</td>
  </tr>
  <tr>
    <td>0x400B</td>
    <td>JP PWOFF</td>
    <td>Disk power off</td>
  </tr>
  <tr>
    <td>0x400E</td>
    <td>JP ERROR</td>
    <td>Error handling routine</td>
  </tr>
  <tr>
    <td>0x4011</td>
    <td>JP RDMAP</td>
    <td>Read the track map of the disk</td>
  </tr>
  <tr>
    <td>0x4014</td>
    <td>JP CLEAR</td>
    <td>Clear a sector of the disk</td>
  </tr>
  <tr>
    <td>0x4017</td>
    <td>JP SVMAP</td>
    <td>Save the track map to the disk</td>
  </tr>
  <tr>
    <td>0x401A</td>
    <td>JP INIT</td>
    <td>Initialise the disk</td>
  </tr>
  <tr>
    <td>0x401D</td>
    <td>JP CSI</td>
    <td>Command string interpreter</td>
  </tr>
  <tr>
    <td>0x4020</td>
    <td>JP HEX</td>
    <td>Convert ASCII to hexadecimal</td>
  </tr>
  <tr>
    <td>0x4023</td>
    <td>JP IDAM</td>
    <td>Read identification address mark</td>
  </tr>
  <tr>
    <td>0x4026</td>
    <td>JP CREATE</td>
    <td>Create an entry in a directory</td>
  </tr>
  <tr>
    <td>0x4029</td>
    <td>JP MAP</td>
    <td>Search for an empty sector</td>
  </tr>
  <tr>
    <td>0x402C</td>
    <td>JP SEARCH</td>
    <td>Search for file in directory</td>
  </tr>
  <tr>
    <td>0x402F</td>
    <td>JP FIND</td>
    <td>Search empty space in directory</td>
  </tr>
  <tr>
    <td>0x4032</td>
    <td>JP WRITE</td>
    <td>Write a sector to disk</td>
  </tr>
  <tr>
    <td>0x4035</td>
    <td>JP READ</td>
    <td>Read a sector from disk</td>
  </tr>
  <tr>
    <td>0x4038</td>
    <td>JP DLY</td>
    <td>Delay miliseconds in register C</td>
  </tr>
  <tr>
    <td>0x403B</td>
    <td>JP STPIN</td>
    <td>Step in</td>
  </tr>
  <tr>
    <td>0x403E</td>
    <td>JP STPOUT</td>
    <td>Step out</td>
  </tr>
  <tr>
    <td>0x4041</td>
    <td>JP DKLOAD</td>
    <td>Load a file from disk</td>
  </tr>
  <tr>
    <td>0x4044</td>
    <td>JP SAVEOB</td>
    <td>Save a file to disk</td>
  </tr>
</table>

<h3>DOS SUBROUTINES</h3>

<h4>PWRON</h4>

<p>Turn ON the power of the drive selected in DOS vector IY+DK. To turn ON drive 1 , 10H should be written to IY+DK. To turn ON drive 2, 80H should be written to IY+DK before calling PWRON.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A</td>
</tr>
</table>

<h4>PWROFF</h4>

<p>Turn OFF the power to the disk. Both disks are turned OFF with the write request line set high at the same time.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A</td>
</tr>
</table>

<h4>ERROR</h4>

<p>This subroutine reads the content of register A and prints the .error message before going back to BASIC.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>The subroutine will re-initialize the BASIC pointers and jump to BASIC.</td>
</tr>
</table>

<br />

<table border="1" bgcolor="white" width="100%">
<tr>
<td><b>Error Code</b></td>
<td><b>Error</b></td>
</tr>

<tr>
<td>0</td>
<td>No error</td>
</tr>

<tr>
<td>1</td>
<td>Syntax error</td>
</tr>

<tr>
<td>2</td>
<td>File already exists</td>
</tr>

<tr>
<td>3</td>
<td>Directory full</td>
</tr>

<tr>
<td>4</td>
<td>Disk write protected</td>
</tr>

<tr>
<td>5</td>
<td>File not open</td>
</tr>

<tr>
<td>6</td>
<td>Disk I/O error</td>
</tr>

<tr>
<td>7</td>
<td>Disk full</td>
</tr>

<tr>
<td>8</td>
<td>File already open</td>
</tr>

<tr>
<td>9</td>
<td>Sector not found</td>
</tr>

<tr>
<td>10</td>
<td>Checksum error</td>
</tr>

<tr>
<td>11</td>
<td>Unsupported device</td>
</tr>

<tr>
<td>12</td>
<td>File type mismach</td>
</tr>

<tr>
<td>13</td>
<td>File not found</td>
</tr>

<tr>
<td>14</td>
<td>Disk buffer full</td>
</tr>

<tr>
<td>15</td>
<td>Illegal read</td>
</tr>

<tr>
<td>16</td>
<td>Illegal write</td>
</tr>

<tr>
<td>17</td>
<td>Break</td>
</tr>
</table>

<h4>RDMAP</h4>

<p>Read the track map from the disk and place it.,into the address pointed to by IY+MAPADR.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Dissable interrupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>CLEAR</h4>

<p>Clear the sector specified in IY+TRCK and IY+SCTR.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Dissable interrupt<br />
Track number in IY+TRCK<br />
Sector number in IY+SCTR</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>SVMAP</h4>

<p>Save the track map in the address pointed by IY+MAPADR to track 0 sector 15 of the disk.</p>

<p>Clear the sector specified in IY+TRCK and IY+SCTR.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Dissable interrupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>INIT</h4>

<p>Initialize a blank disk.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, HL</td>
</tr>
</table>

<h4>CSI</h4>

<p>This subroutine reads the user specified filename and puts into IY+FNAM if the syntax is correct.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Input message pointed to by HL</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, HL</td>
</tr>
</table>

<h4>HEX</h4>

<p>This subroutine converts 4 bytes of ASCII pointed to by HL into DE reg pair.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>HL points to 4 bytes of ASCII</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Carry=1 if error found, DE invalid<br />
Carry=0 if no error, DE=2 bytes of HEX<br />
HL advanced by 4</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, DE, HL</td>
</tr>
</table>

<h4>IDAM</h4>

<p>Search for the identification address mark (IDAM) of the disk.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Desired track in IY+TRCK<br />
Desired sector in IY+SCTR<br />
Disable interupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>CREATE</h4>

<p>Generate an entry in the directory.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>File name in IY+ENAM<br />
File type in IY+TYPE<br />
Disable interupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>MAP</h4>

<p>Search for an empty sector in the track map.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Track map in buffer pointed to by IY+MPADR</td>
</tr>

<tr>
<td>Exit parameters</td>
<td>Error code in A<br />
Next sector available in IY+NSCT<br />
Next track available in IY+NTRK</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>SEARCH</h4>

<p>Search for matching of filename in IY+FNAM with that in the directory.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
File name in IY+FNAM</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>FIND</h4>

<p>Search for an empty space in the directory.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameter</td>
<td>Disable interupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>WRITE</h4>

<p>Write the content of the buffer pointed to by IY+DBFR to the track#, sector# specified by IY+TRCK and IY+SCTR.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Track number in IY+TRCK<br />
Sector number in IY+SCTR<br />
Data to be written in buffer pointed to by IY+DBFR (128 bytes)</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL, BC', DE', HL'</td>
</tr>
</table>

<h4>READ</h4>

<p>Read the content of track#, sector# specified by IY+TRCK and IY+SCTR into the buffer pointed to by IY+DBFR.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Track number in IY+TRCK<br />
Sector number in IY+SCTR<br />
Disable interupt</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A<br />
Read data in buffer pointed to by IY+DBFR (128 bytes)</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>DLY</h4>

<p>Delay N mS specified by B.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
Number of mS to delay in B</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC</td>
</tr>
</table>

<h4>STPIN</h4>

<p>Step the stepper N tracks inwards specified by register B.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
Number of tracks to be stepped in B</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC</td>
</tr>
</table>

<h4>STPOUT</h4>

<p>Step the stepper N tracks outwards specified by register B.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
Number of tracks to be stepped in B</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>NONE</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC</td>
</tr>
</table>

<h4>DKLOAD<br />
</h4>

<p>Load the file specified in IY+FNAM to the memory.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
File name in IY+FNAM</td>
</tr>

<tr>
<td>Exit parameters</td>
<td>Error code in A<br />
File in memory</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL</td>
</tr>
</table>

<h4>SAVEOB</h4>

<p>Save the filename specified in IY+FNAM and pointed to by 78A4H to the disk.</p>

<table border="1" bgcolor="white" width="100%">
<tr>
<td>Entry parameters</td>
<td>Disable interupt<br />
File name in IY+FNAM<br />
File start address in 0x78A4<br />
File end address in 0x78F9<br />
File type in IY_TYPE</td>
</tr>

<tr>
<td>Exit parameter</td>
<td>Error code in A</td>
</tr>

<tr>
<td>Registers affected</td>
<td>A, BC, DE, HL, BC', DE', HL'</td>
</tr>
</table>

<hr />
</body>
</html>

